(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{222:function(e,t,s){"use strict";s.r(t);var n=s(6),a=Object(n.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"backends"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#backends","aria-hidden":"true"}},[e._v("#")]),e._v(" Backends")]),e._v(" "),s("p",[e._v("trilogy supports several different backends, each with its own advantages.")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#sqlite3"}},[s("code",[e._v("sqlite3")])])]),e._v(" "),s("li",[s("a",{attrs:{href:"#sql-js"}},[s("code",[e._v("sql.js")])])]),e._v(" "),s("li",[s("a",{attrs:{href:"#memory-only"}},[e._v("memory-only")])])]),e._v(" "),s("p",[e._v("Because trilogy supports each of these equally, you can choose any one of\nthem depending on which is the best fit for your project. And don't worry\ntoo much about choosing the right one the first time since you can change\nthe backend at any time without affecting trilogy's behavior or changing\nany of your code.")]),e._v(" "),s("h2",{attrs:{id:"sqlite3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sqlite3","aria-hidden":"true"}},[e._v("#")]),e._v(" "),s("a",{attrs:{href:"https://github.com/mapbox/node-sqlite3",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("sqlite3")]),s("OutboundLink")],1)]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" db "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'./storage.db'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  client"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'sqlite3'")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// or, since this is the default:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" db "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'./storage.db'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("p",[e._v("This is the predominant native asynchronous SQLite binding for Node. If you're\nlooking for performance this is a good place to start, and is inherently async.\nHowever since this is a native C++ module it is required to build this against\nyour runtime environment. In most cases a precompiled binary can be downloaded\nby "),s("a",{attrs:{href:"https://github.com/mapbox/node-sqlite3#installing",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("node-pre-gyp")]),s("OutboundLink")],1),e._v(".")]),e._v(" "),s("p",[e._v("Using "),s("code",[e._v("sqlite3")]),e._v(" can sometimes be a hassle due to its C++ nature, "),s("code",[e._v("gyp")]),e._v(", "),s("code",[e._v("pre-gyp")]),e._v(",\nElectron, different OS environments or architectures, Node versions, and so on\nand so on. To help with situations where this is an issue trilogy also supports\na module that does "),s("em",[e._v("not")]),e._v(" require native compilation toolchains.")]),e._v(" "),s("h2",{attrs:{id:"sql-js"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sql-js","aria-hidden":"true"}},[e._v("#")]),e._v(" "),s("a",{attrs:{href:"https://github.com/kripken/sql.js",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("sql.js")]),s("OutboundLink")],1)]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" db "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'./storage.db'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  client"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'sql.js'")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("p",[s("code",[e._v("sql.js")]),e._v(" runs purely in JavaScript and has no native C++ dependency. On the\none hand, this means you can use it in almost any environment and will have no\ntrouble using it in the runtimes trilogy supports.")]),e._v(" "),s("p",[e._v("On the other hand this means performance likely isn't as stellar, and the\nqueries are run synchronously. Synchronous vs asynchronous seems to be a\n"),s("a",{attrs:{href:"https://github.com/JoshuaWise/better-sqlite3/issues/181",target:"_blank",rel:"noopener noreferrer"}},[e._v("matter of debate"),s("OutboundLink")],1),e._v(" when it comes to Node's competing SQLite\nlibraries, trilogy normalizes both of these backends to Promises and you\nwon't need to interact with them differently.")]),e._v(" "),s("h2",{attrs:{id:"memory-only"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#memory-only","aria-hidden":"true"}},[e._v("#")]),e._v(" memory-only")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" db "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("':memory:'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("p",[e._v("Set the file path to exactly "),s("code",[e._v(":memory:")]),e._v(" to disable persistence and store your\ndatabase entirely in memory. None of the data will be saved across sessions,\nbut queries are blazing fast due to the lack of I/O.")]),e._v(" "),s("p",[e._v("In-memory storage is great for tests — trilogy itself uses this for its\ntests ("),s("a",{attrs:{href:"https://github.com/citycide/trilogy/blob/09ae5e6a385cb1b87c6ff1c6fb8122723c81ed64/tests/count.ts#L4",target:"_blank",rel:"noopener noreferrer"}},[e._v("example"),s("OutboundLink")],1),e._v(") — and for performance when persisting\ndata isn't a requirement.")]),e._v(" "),s("p",[e._v("This is a SQLite feature supported by both of the above backends that you can\nread more about "),s("a",{attrs:{href:"https://www.sqlite.org/inmemorydb.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),s("OutboundLink")],1),e._v(".")]),e._v(" "),s("h2",{attrs:{id:"so-which-one"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#so-which-one","aria-hidden":"true"}},[e._v("#")]),e._v(" so... which one?")]),e._v(" "),s("p",[e._v("Which one you choose is dependent on your target environments. It's recommended\nto start with "),s("code",[e._v("sqlite3")]),e._v(" and build it as needed. If you face compatibility\nissues that you'd rather not deal with, you can always switch to "),s("code",[e._v("sql.js")]),e._v(" with\nno changes to the rest of your code - trilogy handles them both in the same way.")]),e._v(" "),s("p",[e._v("If you maintain a cross-platform Electron app, for example, you can use "),s("code",[e._v("sql.js")]),e._v("\nand you won't need to deal with the problems that led to stories like\n"),s("a",{attrs:{href:"http://kodgemisi.com/2015/09/using-sequelize-sqlite-electron-ubuntu-linux/",target:"_blank",rel:"noopener noreferrer"}},[e._v("this"),s("OutboundLink")],1),e._v(" or "),s("a",{attrs:{href:"https://www.bountysource.com/issues/36091005-electron-1-2-x-sqlite3-not-working-on-windows-dll-related-issue",target:"_blank",rel:"noopener noreferrer"}},[e._v("this"),s("OutboundLink")],1),e._v(" or "),s("a",{attrs:{href:"http://www.laurivan.com/make-electron-work-with-sqlite3/",target:"_blank",rel:"noopener noreferrer"}},[e._v("this"),s("OutboundLink")],1),e._v(".")]),e._v(" "),s("p",[e._v("That last link describes the current best way to handle the native "),s("code",[e._v("sqlite3")]),e._v("\nmodule in Electron — tools like "),s("a",{attrs:{href:"https://github.com/electron/electron-rebuild",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("electron-rebuild")]),s("OutboundLink")],1),e._v("\nhave reduced a lot of frustration in using the native "),s("code",[e._v("sqlite3")]),e._v(" module over\nthe "),s("code",[e._v("sql.js")]),e._v(" alternative.")])])},[],!1,null,null,null);t.default=a.exports}}]);